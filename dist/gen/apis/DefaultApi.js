"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultApiResponseProcessor = exports.DefaultApiRequestFactory = void 0;
// TODO: better import syntax?
const baseapi_js_1 = require("./baseapi.js");
const http_js_1 = require("../http/http.js");
const ObjectSerializer_js_1 = require("../models/ObjectSerializer.js");
const exception_js_1 = require("./exception.js");
const util_js_1 = require("../util.js");
/**
 * no description
 */
class DefaultApiRequestFactory extends baseapi_js_1.BaseAPIRequestFactory {
    /**
     * Create a MigrationPolicy object.
     * @param body
     */
    async createMigrationPolicy(body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createMigrationPolicy", "body");
        }
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1MigrationPolicy", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a KubeVirt object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedKubeVirt(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedKubeVirt", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedKubeVirt", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1KubeVirt", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachine object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachine(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachine", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachine", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachine", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineExport object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineExport(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineExport", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineExport", "body");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineExport", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineInstance object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineInstance(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstance", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstance", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstance", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineInstanceMigration object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineInstanceMigration(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstanceMigration", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstanceMigration", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineInstancePreset object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineInstancePreset(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstancePreset", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstancePreset", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineInstanceReplicaSet object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineInstanceReplicaSet(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstanceReplicaSet", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstanceReplicaSet", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineInstancetype object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineInstancetype(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstancetype", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineInstancetype", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachinePool object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachinePool(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachinePool", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachinePool", "body");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1VirtualMachinePool", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachinePreference object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachinePreference(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachinePreference", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachinePreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachinePreference", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineRestore object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineRestore(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineRestore", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineRestore", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineRestore", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineSnapshot object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineSnapshot(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineSnapshot", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineSnapshot", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineSnapshot", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineSnapshotContent object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async createNamespacedVirtualMachineSnapshotContent(namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createNamespacedVirtualMachineSnapshotContent", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineSnapshotContent", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineClone object.
     * @param body
     */
    async createVirtualMachineClone(body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createVirtualMachineClone", "body");
        }
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1VirtualMachineClone", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineClusterInstancetype object.
     * @param body
     */
    async createVirtualMachineClusterInstancetype(body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createVirtualMachineClusterInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineClusterInstancetype", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Create a VirtualMachineClusterPreference object.
     * @param body
     */
    async createVirtualMachineClusterPreference(body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "createVirtualMachineClusterPreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.POST);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineClusterPreference", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of MigrationPolicy objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionMigrationPolicy(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of KubeVirt objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedKubeVirt(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachine objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachine(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineExport objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineExport(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineInstance objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineInstance(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineInstanceMigration objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceMigration(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineInstancePreset objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineInstancePreset(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineInstanceReplicaSet objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineInstanceReplicaSet(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineInstancetype objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineInstancetype(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachinePool objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachinePool(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachinePreference objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachinePreference(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineRestore objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineRestore(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineSnapshot objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshot(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineSnapshotContent objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotContent(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineClone objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionVirtualMachineClone(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineClusterInstancetype objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionVirtualMachineClusterInstancetype(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a collection of VirtualMachineClusterPreference objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async deleteCollectionVirtualMachineClusterPreference(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a MigrationPolicy object.
     * @param name Name of the resource
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteMigrationPolicy(name, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteMigrationPolicy", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteMigrationPolicy", "body");
        }
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a KubeVirt object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedKubeVirt(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedKubeVirt", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedKubeVirt", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedKubeVirt", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachine(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachine", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachine", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachine", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineExport object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineExport(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineExport", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineExport", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineExport", "body");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineInstance(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstance", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstance", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstance", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineInstanceMigration object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineInstanceMigration(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceMigration", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceMigration", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineInstancePreset object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineInstancePreset(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancePreset", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancePreset", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineInstanceReplicaSet object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineInstanceReplicaSet(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceReplicaSet", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstanceReplicaSet", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineInstancetype object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineInstancetype(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancetype", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancetype", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachinePool object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachinePool(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePool", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePool", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePool", "body");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachinePreference object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachinePreference(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePreference", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePreference", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachinePreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineRestore object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineRestore(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineRestore", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineRestore", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineRestore", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineSnapshot object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineSnapshot(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshot", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshot", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineSnapshotContent object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteNamespacedVirtualMachineSnapshotContent(name, namespace, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshotContent", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteNamespacedVirtualMachineSnapshotContent", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineClone object.
     * @param name Name of the resource
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteVirtualMachineClone(name, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClone", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClone", "body");
        }
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineClusterInstancetype object.
     * @param name Name of the resource
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteVirtualMachineClusterInstancetype(name, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClusterInstancetype", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClusterInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Delete a VirtualMachineClusterPreference object.
     * @param name Name of the resource
     * @param body
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     */
    async deleteVirtualMachineClusterPreference(name, body, gracePeriodSeconds, orphanDependents, propagationPolicy, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClusterPreference", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "deleteVirtualMachineClusterPreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.DELETE);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (gracePeriodSeconds !== undefined) {
            requestContext.setQueryParam("gracePeriodSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(gracePeriodSeconds, "number", ""));
        }
        // Query Params
        if (orphanDependents !== undefined) {
            requestContext.setQueryParam("orphanDependents", ObjectSerializer_js_1.ObjectSerializer.serialize(orphanDependents, "boolean", ""));
        }
        // Query Params
        if (propagationPolicy !== undefined) {
            requestContext.setQueryParam("propagationPolicy", ObjectSerializer_js_1.ObjectSerializer.serialize(propagationPolicy, "string", ""));
        }
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "K8sIoApimachineryPkgApisMetaV1DeleteOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Health endpoint
     */
    async func13(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/healthz';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async func6(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/openapi/v2';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupCloneKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupExportKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupInstancetypeKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API GroupList
     */
    async getAPIGroupList(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupMigrationsKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupPoolKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API group
     */
    async getAPIGroupSnapshotKubevirtIo(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesCloneKubevirtIoV1alpha1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesExportKubevirtIoV1beta1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesInstancetypeKubevirtIoV1beta1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesKubevirtIoV1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesMigrationsKubevirtIoV1alpha1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesPoolKubevirtIoV1alpha1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API Resources
     */
    async getAPIResourcesSnapshotKubevirtIoV1beta1(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get KubeVirt API root paths
     */
    async getRootPaths(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * dump profiler results endpoint
     */
    async handleDumpProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/dump-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * start profiler endpoint
     */
    async handleStartProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/start-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * stop profiler endpoint
     */
    async handleStopProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/stop-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all KubeVirt objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listKubeVirtForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/kubevirt';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of MigrationPolicy objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listMigrationPolicy(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of KubeVirt objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedKubeVirt(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedKubeVirt", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachine objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachine(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachine", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineExport objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineExport(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineExport", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineInstance objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineInstance(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineInstance", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineInstanceMigration objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineInstanceMigration(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineInstancePreset objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineInstancePreset(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineInstanceReplicaSet objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineInstanceReplicaSet(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineInstancetype objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineInstancetype(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineInstancetype", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachinePool objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachinePool(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachinePool", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachinePreference objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachinePreference(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachinePreference", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineRestore objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineRestore(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineRestore", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineSnapshot objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineSnapshot(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineSnapshot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineSnapshotContent objects.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listNamespacedVirtualMachineSnapshotContent(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "listNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineClone objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineClone(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineClusterInstancetype objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineClusterInstancetype(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of VirtualMachineClusterPreference objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineClusterPreference(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineExport objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineExportForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/virtualmachineexports';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachine objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/virtualmachines';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineInstance objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineInstanceForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/virtualmachineinstances';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineInstanceMigration objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineInstanceMigrationForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/virtualmachineinstancemigrations';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineInstancePreset objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineInstancePresetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/virtualmachineinstancepresets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineInstanceReplicaSet objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineInstanceReplicaSetForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/virtualmachineinstancereplicasets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineInstancetype objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineInstancetypeForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachinePool objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachinePoolForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/virtualmachinepools';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachinePreference objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachinePreferenceForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachinepreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineRestore objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineRestoreForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinerestores';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineSnapshotContent objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineSnapshotContentForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshotcontents';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a list of all VirtualMachineSnapshot objects.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async listVirtualMachineSnapshotForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/virtualmachinesnapshots';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a MigrationPolicy object.
     * @param name Name of the resource
     * @param body
     */
    async patchMigrationPolicy(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchMigrationPolicy", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchMigrationPolicy", "body");
        }
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a KubeVirt object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedKubeVirt(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedKubeVirt", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedKubeVirt", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedKubeVirt", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachine(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachine", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachine", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachine", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineExport object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineExport(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineExport", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineExport", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineExport", "body");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineInstance(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstance", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstance", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstance", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineInstanceMigration object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineInstanceMigration(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceMigration", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceMigration", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineInstancePreset object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineInstancePreset(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancePreset", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancePreset", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineInstanceReplicaSet object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineInstanceReplicaSet(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceReplicaSet", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstanceReplicaSet", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineInstancetype object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineInstancetype(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancetype", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancetype", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachinePool object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachinePool(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePool", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePool", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePool", "body");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachinePreference object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachinePreference(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePreference", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePreference", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachinePreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineRestore object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineRestore(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineRestore", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineRestore", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineRestore", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineSnapshot object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineSnapshot(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshot", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshot", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineSnapshotContent object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async patchNamespacedVirtualMachineSnapshotContent(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshotContent", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchNamespacedVirtualMachineSnapshotContent", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineClone object.
     * @param name Name of the resource
     * @param body
     */
    async patchVirtualMachineClone(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClone", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClone", "body");
        }
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineClusterInstancetype object.
     * @param name Name of the resource
     * @param body
     */
    async patchVirtualMachineClusterInstancetype(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClusterInstancetype", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClusterInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Patch a VirtualMachineClusterPreference object.
     * @param name Name of the resource
     * @param body
     */
    async patchVirtualMachineClusterPreference(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClusterPreference", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "patchVirtualMachineClusterPreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PATCH);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json-patch+json",
            "application/merge-patch+json"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "any", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a MigrationPolicy object.
     * @param name Name of the resource
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readMigrationPolicy(name, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readMigrationPolicy", "name");
        }
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedKubeVirt(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedKubeVirt", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedKubeVirt", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachine(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachine", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachine", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineExport object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineExport(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineExport", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineExport", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineInstance(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstance", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstance", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineInstanceMigration object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineInstanceMigration(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstanceMigration", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineInstancePreset object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineInstancePreset(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstancePreset", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineInstanceReplicaSet object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineInstanceReplicaSet(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstanceReplicaSet", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineInstancetype object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineInstancetype(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstancetype", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineInstancetype", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachinePool object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachinePool(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachinePool", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachinePool", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachinePreference object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachinePreference(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachinePreference", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachinePreference", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineRestore object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineRestore(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineRestore", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineRestore", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineSnapshot object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineSnapshot(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineSnapshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineSnapshot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineSnapshotContent object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readNamespacedVirtualMachineSnapshotContent(name, namespace, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineSnapshotContent", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineClone object.
     * @param name Name of the resource
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readVirtualMachineClone(name, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readVirtualMachineClone", "name");
        }
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineClusterInstancetype object.
     * @param name Name of the resource
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readVirtualMachineClusterInstancetype(name, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readVirtualMachineClusterInstancetype", "name");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a VirtualMachineClusterPreference object.
     * @param name Name of the resource
     * @param exact Should the export be exact. Exact export maintains cluster-specific fields like \&#39;Namespace\&#39;.
     * @param _export Should this value be exported. Export strips fields that a user can not specify.
     */
    async readVirtualMachineClusterPreference(name, exact, _export, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "readVirtualMachineClusterPreference", "name");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (exact !== undefined) {
            requestContext.setQueryParam("exact", ObjectSerializer_js_1.ObjectSerializer.serialize(exact, "boolean", ""));
        }
        // Query Params
        if (_export !== undefined) {
            requestContext.setQueryParam("export", ObjectSerializer_js_1.ObjectSerializer.serialize(_export, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a MigrationPolicy object.
     * @param name Name of the resource
     * @param body
     */
    async replaceMigrationPolicy(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceMigrationPolicy", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceMigrationPolicy", "body");
        }
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/migrationpolicies/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1MigrationPolicy", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a KubeVirt object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedKubeVirt(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedKubeVirt", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedKubeVirt", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedKubeVirt", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/kubevirt/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1KubeVirt", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachine(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachine", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachine", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachine", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachine", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineExport object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineExport(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineExport", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineExport", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineExport", "body");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineexports/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineExport", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineInstance(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstance", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstance", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstance", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstance", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineInstanceMigration object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineInstanceMigration(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceMigration", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceMigration", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancemigrations/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstanceMigration", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineInstancePreset object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineInstancePreset(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancePreset", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancePreset", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancepresets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstancePreset", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineInstanceReplicaSet object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineInstanceReplicaSet(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceReplicaSet", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstanceReplicaSet", "body");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstancereplicasets/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineInstanceReplicaSet", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineInstancetype object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineInstancetype(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancetype", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancetype", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachineinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineInstancetype", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachinePool object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachinePool(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePool", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePool", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePool", "body");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/namespaces/{namespace}/virtualmachinepools/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1VirtualMachinePool", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachinePreference object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachinePreference(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePreference", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePreference", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachinePreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinepreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachinePreference", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineRestore object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineRestore(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineRestore", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineRestore", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineRestore", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinerestores/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineRestore", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineSnapshot object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineSnapshot(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshot", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshot", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshots/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineSnapshot", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineSnapshotContent object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async replaceNamespacedVirtualMachineSnapshotContent(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshotContent", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceNamespacedVirtualMachineSnapshotContent", "body");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/namespaces/{namespace}/virtualmachinesnapshotcontents/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineSnapshotContent", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineClone object.
     * @param name Name of the resource
     * @param body
     */
    async replaceVirtualMachineClone(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClone", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClone", "body");
        }
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/virtualmachineclones/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1alpha1VirtualMachineClone", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineClusterInstancetype object.
     * @param name Name of the resource
     * @param body
     */
    async replaceVirtualMachineClusterInstancetype(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClusterInstancetype", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClusterInstancetype", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterinstancetypes/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineClusterInstancetype", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Update a VirtualMachineClusterPreference object.
     * @param name Name of the resource
     * @param body
     */
    async replaceVirtualMachineClusterPreference(name, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClusterPreference", "name");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "replaceVirtualMachineClusterPreference", "body");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/virtualmachineclusterpreferences/{name}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([
            "application/json",
            "application/yaml"
        ]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1beta1VirtualMachineClusterPreference", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Health endpoint
     */
    async v1CheckHealth(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/healthz';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1Console(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Console", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Console", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/console'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1ExpandSpec(namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1ExpandSpec", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/expand-vm-spec'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get list of active filesystems on guest machine via guest agent
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1Filesystemlist(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Filesystemlist", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Filesystemlist", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Freeze a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Freeze(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Freeze", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Freeze", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Freeze", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/freeze'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1FreezeUnfreezeTimeout", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API Group
     */
    async v1GetSubAPIGroup(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1Guestfs(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/guestfs';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get guest agent os information
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1Guestosinfo(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Guestosinfo", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Guestosinfo", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Dumps a VirtualMachineInstance memory.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1MemoryDump(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1MemoryDump", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1MemoryDump", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1MemoryDump", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/memorydump'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineMemoryDumpRequest", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Migrate a running VirtualMachine to another node.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Migrate(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Migrate", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Migrate", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Migrate", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/migrate'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1MigrateOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Pause a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Pause(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Pause", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Pause", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Pause", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/pause'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1PauseOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Remove memory dump association.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1RemoveMemoryDump(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1RemoveMemoryDump", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1RemoveMemoryDump", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removememorydump'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Restart a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Restart(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Restart", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Restart", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/restart'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RestartOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1SEVFetchCertChain(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVFetchCertChain", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVFetchCertChain", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Inject SEV launch secret into a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1SEVInjectLaunchSecret(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVInjectLaunchSecret", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVInjectLaunchSecret", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVInjectLaunchSecret", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1SEVSecretOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Query SEV launch measurement from a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1SEVQueryLaunchMeasurement(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVQueryLaunchMeasurement", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVQueryLaunchMeasurement", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Setup SEV session parameters for a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1SEVSetupSession(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVSetupSession", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVSetupSession", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SEVSetupSession", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1SEVSessionOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Soft reboot a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1SoftReboot(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SoftReboot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1SoftReboot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Start a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Start(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Start", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Start", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Start", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/start'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1StartOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Stop a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Stop(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Stop", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Stop", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/stop'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1StopOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Unfreeze a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1Unfreeze(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Unfreeze", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Unfreeze", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Unpause a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1Unpause(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Unpause", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Unpause", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Unpause", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/unpause'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1UnpauseOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get list of active users via guest agent
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1Userlist(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Userlist", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1Userlist", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/userlist'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1VNC(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VNC", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VNC", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param moveCursor Move the cursor on the VNC display to wake up the screen
     */
    async v1VNCScreenshot(name, namespace, moveCursor, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VNCScreenshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VNCScreenshot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (moveCursor !== undefined) {
            requestContext.setQueryParam("moveCursor", ObjectSerializer_js_1.ObjectSerializer.serialize(moveCursor, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The port which the VSOCK application listens to.
     * @param tls Weather to request a TLS encrypted session from the VSOCK application.
     */
    async v1VSOCK(name, namespace, port, tls, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VSOCK", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VSOCK", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1VSOCK", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/vsock'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (port !== undefined) {
            requestContext.setQueryParam("port", ObjectSerializer_js_1.ObjectSerializer.serialize(port, "number", ""));
        }
        // Query Params
        if (tls !== undefined) {
            requestContext.setQueryParam("tls", ObjectSerializer_js_1.ObjectSerializer.serialize(tls, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1Version(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/version';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Health endpoint
     */
    async v1alpha3CheckHealth(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/healthz';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to a serial console on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3Console(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Console", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Console", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/console'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Expands instancetype and preference into the passed VirtualMachine object.
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3ExpandSpec(namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3ExpandSpec", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/expand-vm-spec'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get list of active filesystems on guest machine via guest agent
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3Filesystemlist(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Filesystemlist", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Filesystemlist", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/filesystemlist'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Freeze a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Freeze(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Freeze", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Freeze", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Freeze", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/freeze'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1FreezeUnfreezeTimeout", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1alpha3Guestfs(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/guestfs';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get guest agent os information
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3Guestosinfo(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Guestosinfo", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Guestosinfo", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/guestosinfo'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Dumps a VirtualMachineInstance memory.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3MemoryDump(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3MemoryDump", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3MemoryDump", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3MemoryDump", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/memorydump'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1VirtualMachineMemoryDumpRequest", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Migrate a running VirtualMachine to another node.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Migrate(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Migrate", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Migrate", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Migrate", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/migrate'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1MigrateOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Pause a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Pause(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Pause", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Pause", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Pause", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/pause'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1PauseOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Remove memory dump association.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3RemoveMemoryDump(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3RemoveMemoryDump", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3RemoveMemoryDump", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removememorydump'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Restart a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Restart(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Restart", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Restart", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/restart'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RestartOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Fetch SEV certificate chain from the node where Virtual Machine is scheduled
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3SEVFetchCertChain(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVFetchCertChain", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVFetchCertChain", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/fetchcertchain'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Inject SEV launch secret into a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3SEVInjectLaunchSecret(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVInjectLaunchSecret", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVInjectLaunchSecret", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVInjectLaunchSecret", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/injectlaunchsecret'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1SEVSecretOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Query SEV launch measurement from a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3SEVQueryLaunchMeasurement(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVQueryLaunchMeasurement", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVQueryLaunchMeasurement", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/querylaunchmeasurement'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Setup SEV session parameters for a Virtual Machine
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3SEVSetupSession(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVSetupSession", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVSetupSession", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SEVSetupSession", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/sev/setupsession'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1SEVSessionOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Soft reboot a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3SoftReboot(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SoftReboot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3SoftReboot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/softreboot'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Start a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Start(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Start", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Start", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Start", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/start'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1StartOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Stop a VirtualMachine object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Stop(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Stop", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Stop", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/stop'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1StopOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Unfreeze a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3Unfreeze(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Unfreeze", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Unfreeze", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unfreeze'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Unpause a VirtualMachineInstance object.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3Unpause(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Unpause", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Unpause", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Unpause", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/unpause'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1UnpauseOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get list of active users via guest agent
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3Userlist(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Userlist", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3Userlist", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/userlist'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to connect to VNC on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3VNC(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VNC", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VNC", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a PNG VNC screenshot of the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param moveCursor Move the cursor on the VNC display to wake up the screen
     */
    async v1alpha3VNCScreenshot(name, namespace, moveCursor, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VNCScreenshot", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VNCScreenshot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vnc/screenshot'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (moveCursor !== undefined) {
            requestContext.setQueryParam("moveCursor", ObjectSerializer_js_1.ObjectSerializer.serialize(moveCursor, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port via VSOCK.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The port which the VSOCK application listens to.
     * @param tls Weather to request a TLS encrypted session from the VSOCK application.
     */
    async v1alpha3VSOCK(name, namespace, port, tls, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VSOCK", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VSOCK", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3VSOCK", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/vsock'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (port !== undefined) {
            requestContext.setQueryParam("port", ObjectSerializer_js_1.ObjectSerializer.serialize(port, "number", ""));
        }
        // Query Params
        if (tls !== undefined) {
            requestContext.setQueryParam("tls", ObjectSerializer_js_1.ObjectSerializer.serialize(tls, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1alpha3Version(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/version';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1alpha3dumpClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/dump-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API resources
     */
    async v1alpha3getAPISubResources(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1alpha3startClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/start-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1alpha3stopClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/stop-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3usbredir(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3usbredir", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3usbredir", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Add a volume and disk to a running Virtual Machine.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3vmAddvolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmAddvolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmAddvolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmAddvolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/addvolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1AddVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1alpha3vmExpandSpec(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmExpandSpec", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmExpandSpec", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/expand-spec'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     */
    async v1alpha3vmPortForward(name, namespace, port, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForward", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForward", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForward", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     * @param protocol The protocol for portforward on the VirtualMachineInstance.
     */
    async v1alpha3vmPortForwardWithProtocol(name, namespace, port, protocol, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForwardWithProtocol", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForwardWithProtocol", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForwardWithProtocol", "port");
        }
        // verify required parameter 'protocol' is not null or undefined
        if (protocol === null || protocol === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmPortForwardWithProtocol", "protocol");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)))
            .replace('{' + 'protocol' + '}', encodeURIComponent(String(protocol)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Removes a volume and disk from a running Virtual Machine.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3vmRemovevolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmRemovevolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmRemovevolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmRemovevolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachines/{name}/removevolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RemoveVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Add a volume and disk to a running Virtual Machine Instance
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3vmiAddvolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiAddvolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiAddvolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiAddvolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1AddVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     */
    async v1alpha3vmiPortForward(name, namespace, port, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForward", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForward", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForward", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     * @param protocol The protocol for portforward on the VirtualMachineInstance.
     */
    async v1alpha3vmiPortForwardWithProtocol(name, namespace, port, protocol, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForwardWithProtocol", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForwardWithProtocol", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForwardWithProtocol", "port");
        }
        // verify required parameter 'protocol' is not null or undefined
        if (protocol === null || protocol === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiPortForwardWithProtocol", "protocol");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)))
            .replace('{' + 'protocol' + '}', encodeURIComponent(String(protocol)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1alpha3vmiRemovevolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiRemovevolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiRemovevolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1alpha3vmiRemovevolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1alpha3/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RemoveVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1dumpClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/dump-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get a KubeVirt API resources
     */
    async v1getAPISubResources(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1startClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/start-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     */
    async v1stopClusterProfiler(_options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/stop-cluster-profiler';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection to connect to USB device on the specified VirtualMachineInstance.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1usbredir(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1usbredir", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1usbredir", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/usbredir'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Add a volume and disk to a running Virtual Machine.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1vmAddvolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmAddvolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmAddvolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmAddvolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/addvolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1AddVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Get VirtualMachine object with expanded instancetype and preference.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     */
    async v1vmExpandSpec(name, namespace, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmExpandSpec", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmExpandSpec", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/expand-spec'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the running VMI for the specified VirtualMachine and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     */
    async v1vmPortForward(name, namespace, port, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForward", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForward", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForward", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachine and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     * @param protocol The protocol for portforward on the VirtualMachineInstance.
     */
    async v1vmPortForwardWithProtocol(name, namespace, port, protocol, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForwardWithProtocol", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForwardWithProtocol", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForwardWithProtocol", "port");
        }
        // verify required parameter 'protocol' is not null or undefined
        if (protocol === null || protocol === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmPortForwardWithProtocol", "protocol");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/portforward/{port}/{protocol}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)))
            .replace('{' + 'protocol' + '}', encodeURIComponent(String(protocol)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Removes a volume and disk from a running Virtual Machine.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1vmRemovevolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmRemovevolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmRemovevolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmRemovevolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachines/{name}/removevolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RemoveVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Add a volume and disk to a running Virtual Machine Instance
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1vmiAddvolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiAddvolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiAddvolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiAddvolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/addvolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1AddVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic to the specified VirtualMachineInstance and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     */
    async v1vmiPortForward(name, namespace, port, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForward", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForward", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForward", "port");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Open a websocket connection forwarding traffic of the specified protocol (either tcp or udp) to the specified VirtualMachineInstance and port.
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param port The target port for portforward on the VirtualMachineInstance.
     * @param protocol The protocol for portforward on the VirtualMachineInstance.
     */
    async v1vmiPortForwardWithProtocol(name, namespace, port, protocol, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForwardWithProtocol", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForwardWithProtocol", "namespace");
        }
        // verify required parameter 'port' is not null or undefined
        if (port === null || port === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForwardWithProtocol", "port");
        }
        // verify required parameter 'protocol' is not null or undefined
        if (protocol === null || protocol === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiPortForwardWithProtocol", "protocol");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/portforward/{port}/{protocol}'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)))
            .replace('{' + 'port' + '}', encodeURIComponent(String(port)))
            .replace('{' + 'protocol' + '}', encodeURIComponent(String(protocol)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Removes a volume and disk from a running Virtual Machine Instance
     * @param name Name of the resource
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param body
     */
    async v1vmiRemovevolume(name, namespace, body, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiRemovevolume", "name");
        }
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiRemovevolume", "namespace");
        }
        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "v1vmiRemovevolume", "body");
        }
        // Path Params
        const localVarPath = '/apis/subresources.kubevirt.io/v1/namespaces/{namespace}/virtualmachineinstances/{name}/removevolume'
            .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.PUT);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Body Params
        const contentType = ObjectSerializer_js_1.ObjectSerializer.getPreferredMediaType([]);
        requestContext.setHeaderParam("Content-Type", contentType);
        const serializedBody = ObjectSerializer_js_1.ObjectSerializer.stringify(ObjectSerializer_js_1.ObjectSerializer.serialize(body, "V1RemoveVolumeOptions", ""), contentType);
        requestContext.setBody(serializedBody);
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a KubeVirtList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchKubeVirtListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/kubevirt';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a MigrationPolicyList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchMigrationPolicyListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/migrations.kubevirt.io/v1alpha1/watch/migrationpolicies';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a KubeVirt object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedKubeVirt(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedKubeVirt", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/kubevirt'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachine object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachine(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachine", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachines'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineExport object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineExport(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineExport", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineexports'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstance object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineInstance(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineInstance", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstances'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstanceMigration object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineInstanceMigration(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineInstanceMigration", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancemigrations'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstancePreset object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineInstancePreset(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineInstancePreset", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancepresets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstanceReplicaSet object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineInstanceReplicaSet(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineInstanceReplicaSet", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/namespaces/{namespace}/virtualmachineinstancereplicasets'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstancetype object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineInstancetype(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineInstancetype", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachineinstancetypes'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachinePool object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachinePool(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachinePool", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/watch/namespaces/{namespace}/virtualmachinepools'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachinePreference object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachinePreference(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachinePreference", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinepreferences'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineRestore object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineRestore(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineRestore", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinerestores'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineSnapshot object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineSnapshot(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineSnapshot", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshots'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineSnapshotContent object.
     * @param namespace Object name and auth scope, such as for teams and projects
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchNamespacedVirtualMachineSnapshotContent(namespace, _continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new baseapi_js_1.RequiredError("DefaultApi", "watchNamespacedVirtualMachineSnapshotContent", "namespace");
        }
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/namespaces/{namespace}/virtualmachinesnapshotcontents'
            .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineCloneList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineCloneListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/clone.kubevirt.io/v1alpha1/watch/virtualmachineclones';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineClusterInstancetypeList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineClusterInstancetypeListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineClusterPreferenceList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineClusterPreferenceListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineclusterpreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineExportList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineExportListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/export.kubevirt.io/v1beta1/watch/virtualmachineexports';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstanceList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineInstanceListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/virtualmachineinstances';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstanceMigrationList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineInstanceMigrationListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/virtualmachineinstancemigrations';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstancePresetList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineInstancePresetListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/virtualmachineinstancepresets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstanceReplicaSetList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineInstanceReplicaSetListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/virtualmachineinstancereplicasets';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineInstancetypeList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineInstancetypeListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachineinstancetypes';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/kubevirt.io/v1/watch/virtualmachines';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachinePoolList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachinePoolListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/pool.kubevirt.io/v1alpha1/watch/virtualmachinepools';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachinePreferenceList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachinePreferenceListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/instancetype.kubevirt.io/v1beta1/watch/virtualmachinepreferences';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineRestoreList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineRestoreListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinerestores';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineSnapshotContentList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineSnapshotContentListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshotcontents';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
    /**
     * Watch a VirtualMachineSnapshotList object.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server the server will respond with a 410 ResourceExpired error indicating the client must restart their list without the continue field. This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param includeUninitialized If true, partially initialized resources are included in the response.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history.
     * @param timeoutSeconds TimeoutSeconds for the list/watch call.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    async watchVirtualMachineSnapshotListForAllNamespaces(_continue, fieldSelector, includeUninitialized, labelSelector, limit, resourceVersion, timeoutSeconds, watch, _options) {
        let _config = _options || this.configuration;
        // Path Params
        const localVarPath = '/apis/snapshot.kubevirt.io/v1beta1/watch/virtualmachinesnapshots';
        // Make Request Context
        const requestContext = _config.baseServer.makeRequestContext(localVarPath, http_js_1.HttpMethod.GET);
        requestContext.setHeaderParam("Accept", "application/json, */*;q=0.8");
        // Query Params
        if (_continue !== undefined) {
            requestContext.setQueryParam("continue", ObjectSerializer_js_1.ObjectSerializer.serialize(_continue, "string", ""));
        }
        // Query Params
        if (fieldSelector !== undefined) {
            requestContext.setQueryParam("fieldSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(fieldSelector, "string", ""));
        }
        // Query Params
        if (includeUninitialized !== undefined) {
            requestContext.setQueryParam("includeUninitialized", ObjectSerializer_js_1.ObjectSerializer.serialize(includeUninitialized, "boolean", ""));
        }
        // Query Params
        if (labelSelector !== undefined) {
            requestContext.setQueryParam("labelSelector", ObjectSerializer_js_1.ObjectSerializer.serialize(labelSelector, "string", ""));
        }
        // Query Params
        if (limit !== undefined) {
            requestContext.setQueryParam("limit", ObjectSerializer_js_1.ObjectSerializer.serialize(limit, "number", ""));
        }
        // Query Params
        if (resourceVersion !== undefined) {
            requestContext.setQueryParam("resourceVersion", ObjectSerializer_js_1.ObjectSerializer.serialize(resourceVersion, "string", ""));
        }
        // Query Params
        if (timeoutSeconds !== undefined) {
            requestContext.setQueryParam("timeoutSeconds", ObjectSerializer_js_1.ObjectSerializer.serialize(timeoutSeconds, "number", ""));
        }
        // Query Params
        if (watch !== undefined) {
            requestContext.setQueryParam("watch", ObjectSerializer_js_1.ObjectSerializer.serialize(watch, "boolean", ""));
        }
        const defaultAuth = _config?.authMethods?.default;
        if (defaultAuth?.applySecurityAuthentication) {
            await defaultAuth?.applySecurityAuthentication(requestContext);
        }
        return requestContext;
    }
}
exports.DefaultApiRequestFactory = DefaultApiRequestFactory;
class DefaultApiResponseProcessor {
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to createVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async createVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("202", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteCollectionVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteCollectionVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to deleteVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async deleteVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1Status", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to func13
     * @throws ApiException if the response code was not in [200, 299]
     */
    async func13WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to func6
     * @throws ApiException if the response code was not in [200, 299]
     */
    async func6WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupCloneKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupCloneKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupExportKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupExportKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupInstancetypeKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupInstancetypeKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupList
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupListWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroupList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroupList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupMigrationsKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupMigrationsKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupPoolKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupPoolKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIGroupSnapshotKubevirtIo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIGroupSnapshotKubevirtIoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesCloneKubevirtIoV1alpha1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesCloneKubevirtIoV1alpha1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesExportKubevirtIoV1beta1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesExportKubevirtIoV1beta1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesInstancetypeKubevirtIoV1beta1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesInstancetypeKubevirtIoV1beta1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesKubevirtIoV1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesKubevirtIoV1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesMigrationsKubevirtIoV1alpha1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesMigrationsKubevirtIoV1alpha1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesPoolKubevirtIoV1alpha1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesPoolKubevirtIoV1alpha1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getAPIResourcesSnapshotKubevirtIoV1beta1
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getAPIResourcesSnapshotKubevirtIoV1beta1WithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to getRootPaths
     * @throws ApiException if the response code was not in [200, 299]
     */
    async getRootPathsWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1RootPaths", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1RootPaths", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to handleDumpProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async handleDumpProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to handleStartProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async handleStartProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to handleStopProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async handleStopProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listKubeVirtForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listKubeVirtForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirtList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirtList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicyList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicyList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirtList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirtList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExportList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExportList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigrationList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigrationList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePresetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePresetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePoolList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePoolList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestoreList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestoreList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContentList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContentList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineCloneList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineCloneList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineExportForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineExportForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExportList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExportList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineInstanceForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineInstanceForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineInstanceMigrationForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineInstanceMigrationForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigrationList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigrationList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineInstancePresetForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineInstancePresetForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePresetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePresetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineInstanceReplicaSetForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineInstanceReplicaSetForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSetList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineInstancetypeForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineInstancetypeForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetypeList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachinePoolForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachinePoolForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePoolList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePoolList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachinePreferenceForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachinePreferenceForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreferenceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineRestoreForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineRestoreForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestoreList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestoreList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineSnapshotContentForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineSnapshotContentForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContentList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContentList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to listVirtualMachineSnapshotForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async listVirtualMachineSnapshotForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to patchVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async patchVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to readVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async readVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceMigrationPolicy
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceMigrationPolicyWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1MigrationPolicy", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1KubeVirt", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachine", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineExport", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstance", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceMigration", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstancePreset", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceReplicaSet", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachinePool", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachinePreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineRestore", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshot", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineSnapshotContent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceVirtualMachineClone
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceVirtualMachineCloneWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1alpha1VirtualMachineClone", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceVirtualMachineClusterInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceVirtualMachineClusterInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterInstancetype", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to replaceVirtualMachineClusterPreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async replaceVirtualMachineClusterPreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("201", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1beta1VirtualMachineClusterPreference", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1CheckHealth
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1CheckHealthWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unhealthy", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Console
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1ConsoleWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1ExpandSpec
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1ExpandSpecWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Filesystemlist
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1FilesystemlistWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceFileSystemList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceFileSystemList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Freeze
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1FreezeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1GetSubAPIGroup
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1GetSubAPIGroupWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIGroup", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Guestfs
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1GuestfsWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Guestosinfo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1GuestosinfoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestAgentInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestAgentInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1MemoryDump
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1MemoryDumpWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Migrate
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1MigrateWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Pause
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1PauseWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1RemoveMemoryDump
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1RemoveMemoryDumpWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Restart
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1RestartWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1SEVFetchCertChain
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1SEVFetchCertChainWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVPlatformInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVPlatformInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1SEVInjectLaunchSecret
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1SEVInjectLaunchSecretWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1SEVQueryLaunchMeasurement
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1SEVQueryLaunchMeasurementWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVMeasurementInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVMeasurementInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1SEVSetupSession
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1SEVSetupSessionWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1SoftReboot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1SoftRebootWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Start
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1StartWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Stop
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1StopWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Unfreeze
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1UnfreezeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Unpause
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1UnpauseWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Userlist
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1UserlistWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestOSUserList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestOSUserList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1VNC
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1VNCWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1VNCScreenshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1VNCScreenshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1VSOCK
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1VSOCKWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1Version
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1VersionWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3CheckHealth
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3CheckHealthWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unhealthy", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Console
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3ConsoleWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3ExpandSpec
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3ExpandSpecWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Filesystemlist
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3FilesystemlistWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceFileSystemList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceFileSystemList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Freeze
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3FreezeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Guestfs
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3GuestfsWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Guestosinfo
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3GuestosinfoWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestAgentInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestAgentInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3MemoryDump
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3MemoryDumpWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Migrate
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3MigrateWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Pause
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3PauseWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3RemoveMemoryDump
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3RemoveMemoryDumpWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Restart
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3RestartWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3SEVFetchCertChain
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3SEVFetchCertChainWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVPlatformInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVPlatformInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3SEVInjectLaunchSecret
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3SEVInjectLaunchSecretWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3SEVQueryLaunchMeasurement
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3SEVQueryLaunchMeasurementWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVMeasurementInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1SEVMeasurementInfo", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3SEVSetupSession
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3SEVSetupSessionWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3SoftReboot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3SoftRebootWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Start
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3StartWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Stop
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3StopWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Unfreeze
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3UnfreezeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Unpause
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3UnpauseWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Userlist
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3UserlistWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestOSUserList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "V1VirtualMachineInstanceGuestOSUserList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3VNC
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3VNCWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3VNCScreenshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3VNCScreenshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3VSOCK
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3VSOCKWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3Version
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3VersionWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3dumpClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3dumpClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3getAPISubResources
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3getAPISubResourcesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3startClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3startClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3stopClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3stopClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3usbredir
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3usbredirWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmAddvolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmAddvolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmExpandSpec
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmExpandSpecWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmPortForward
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmPortForwardWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmPortForwardWithProtocol
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmPortForwardWithProtocolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmRemovevolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmRemovevolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmiAddvolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmiAddvolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmiPortForward
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmiPortForwardWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmiPortForwardWithProtocol
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmiPortForwardWithProtocolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1alpha3vmiRemovevolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1alpha3vmiRemovevolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1dumpClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1dumpClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1getAPISubResources
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1getAPISubResourcesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1APIResourceList", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1startClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1startClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1stopClusterProfiler
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1stopClusterProfilerWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1usbredir
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1usbredirWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmAddvolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmAddvolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmExpandSpec
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmExpandSpecWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("404", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Not Found", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("500", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Internal Server Error", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmPortForward
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmPortForwardWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmPortForwardWithProtocol
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmPortForwardWithProtocolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmRemovevolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmRemovevolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmiAddvolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmiAddvolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmiPortForward
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmiPortForwardWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmiPortForwardWithProtocol
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmiPortForwardWithProtocolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, undefined);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to v1vmiRemovevolume
     * @throws ApiException if the response code was not in [200, 299]
     */
    async v1vmiRemovevolumeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("400", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Bad Request", body, response.headers);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", undefined, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchKubeVirtListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchKubeVirtListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchMigrationPolicyListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchMigrationPolicyListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedKubeVirt
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedKubeVirtWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachine
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineExport
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineExportWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineInstance
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineInstanceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineInstanceMigration
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineInstanceMigrationWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineInstancePreset
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineInstancePresetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineInstanceReplicaSet
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineInstanceReplicaSetWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineInstancetype
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineInstancetypeWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachinePool
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachinePoolWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachinePreference
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachinePreferenceWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineRestore
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineRestoreWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineSnapshot
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineSnapshotWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchNamespacedVirtualMachineSnapshotContent
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchNamespacedVirtualMachineSnapshotContentWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineCloneListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineCloneListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineClusterInstancetypeListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineClusterInstancetypeListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineClusterPreferenceListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineClusterPreferenceListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineExportListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineExportListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineInstanceListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineInstanceListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineInstanceMigrationListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineInstanceMigrationListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineInstancePresetListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineInstancePresetListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineInstanceReplicaSetListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineInstanceReplicaSetListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineInstancetypeListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineInstancetypeListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachinePoolListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachinePoolListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachinePreferenceListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachinePreferenceListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineRestoreListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineRestoreListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineSnapshotContentListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineSnapshotContentListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
    /**
     * Unwraps the actual response sent by the server from the response context and deserializes the response content
     * to the expected objects
     *
     * @params response Response returned by the server for a request to watchVirtualMachineSnapshotListForAllNamespaces
     * @throws ApiException if the response code was not in [200, 299]
     */
    async watchVirtualMachineSnapshotListForAllNamespacesWithHttpInfo(response) {
        const contentType = ObjectSerializer_js_1.ObjectSerializer.normalizeMediaType(response.headers["content-type"]);
        if ((0, util_js_1.isCodeInRange)("200", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        if ((0, util_js_1.isCodeInRange)("401", response.httpStatusCode)) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "string", "");
            throw new exception_js_1.ApiException(response.httpStatusCode, "Unauthorized", body, response.headers);
        }
        // Work around for missing responses in specification, e.g. for petstore.yaml
        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {
            const body = ObjectSerializer_js_1.ObjectSerializer.deserialize(ObjectSerializer_js_1.ObjectSerializer.parse(await response.body.text(), contentType), "K8sIoApimachineryPkgApisMetaV1WatchEvent", "");
            return new http_js_1.HttpInfo(response.httpStatusCode, response.headers, response.body, body);
        }
        throw new exception_js_1.ApiException(response.httpStatusCode, "Unknown API Status Code!", await response.getBodyAsAny(), response.headers);
    }
}
exports.DefaultApiResponseProcessor = DefaultApiResponseProcessor;
//# sourceMappingURL=DefaultApi.js.map